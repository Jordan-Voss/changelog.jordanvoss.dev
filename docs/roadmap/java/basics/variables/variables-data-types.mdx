---
id: variables-data-types
title: Variables and Data Types
sidebar_label: Variables & Data Types
slug: /roadmap/java/basics/variables/variables-data-types
---

# â˜• Java Variables & Data Types

Understanding variables and data types is foundational to programming in Java. This section breaks down what they are, how they're used, and some common pitfalls.

---

## ðŸ§® What is a Variable?

A **variable** is a container that holds data during the execution of a program. In Java, every variable must be declared with a **type**. **Declaring a variable** means telling the compiler what type of data you want to store and what you want to name that storage location.

### Syntax

```java
type variableName = value;
```
`type` -> the **data type** of the variable (e.g. `int`, `String`)

`variableName` -> the **identifier** or **name** you assign to the variable.

### Declaring vs Initialising

* Variable **declaration** tells the compiler the **name** and **type** of the variable
* Variable **initialisation** assigns an initial value to the variable
You can declare and initialise variables at the same time
```java
int age = 27;
String name = "Jordan";
```
This example will:

* Create a variable called `age` that will store the `int` `27`.

* Create a variable called `name` that will store the `String` (object) `'Jordan'`

**Or**

You can declare the variable first and assign a value later.
```java
int age;
age = 27;
```

---

## ðŸ“¦ Java Data Types

Java is a **statically typed** language, which means each variableâ€™s type must be known at compile time. Javaâ€™s data types are divided into two groups:

* Primitive Types
* Object References

The key difference is where and how the value is stored:

* Primitive values live on the **stack**

* Objects live Variablein the **heap**, and the variable holds a reference to the heap in the stack.

### 1. **Primitive Types**

There are 8 primitive types:

| Type     | Size     | Range / Notes                                                                  | Example                | Description                   |
|----------|---Variable                                                        | `byte b = 1;`           | Very small integer            |
| `short`  | 16-bit   | -32,768 to 32,767                                                                | `short s = 2;`          | Small integer                 |
| `int`    | 32-bit   | -2,147,483,648 to 2,147,483,647                                                  | `int i = 10;`           | Most common integer type      |
| `long`   | 64-bit   | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807                          | `long l = 100000L;`     | Large integer                 |
| `float`  | 32-bit   | Approx. Â±3.4e38, 6â€“7 decimal digits precision                                     | `float f = 3.14f;`      | Decimal (requires `f` suffix) |
| `double` | 64-bit   | Approx. Â±1.8e308, 15 decimal digits precision                                    | `double d = 3.14;`      | More precise decimal          |
| `char`   | 16-bit   | Unicode characters, e.g., `'A'`, `'1'`, `'\u0041'`                               | `char c = 'A';`         | A single character            |

When declaring a variable that is a **primitive type** the actual value is stored in the memory allocated to that variable

```java int a = 10;
int b = a;
b = 20;
// 'a' is still 10, because 'b' is a separate piece of memory copied from 'a'
```
![Primitive Types](/img/Primitive-types.png)

### 2. **Reference Types** (objects)

Reference types store a **reference (memory address)** that points to the actual object stored in the **heap**. The reference itself is stored in the **stack**, but the object it refers to lives in the heap.


| Type        | Size   | Mutability | Example                  | Description                    |
| ----------- | ------ | ---------- | ------------------------ | ------------------------------ |
| `Boolean`   | 1-bit  | Immutable  | `Boolean isTrue = true;` | Wrapper for `boolean`          |
| `Byte`      | 8-bit  | Immutable  | `Byte b = 1;`            | Wrapper for `byte`             |
| `Short`     | 16-bit | Immutable  | `Short s = 2;`           | Wrapper for `short`            |
| `Character` | 16-bit | Immutable  | `Character c = 'A';`     | Wrapper for `char`             |
| `Integer`   | 32-bit | Immutable  | `Integer i = 10;`        | Wrapper for `int`              |
| `Long`      | 64-bit | Immutable  | `Long l = 100000L;`      | Wrapper for `long`             |
| `Float`     | 32-bit | Immutable  | `Float f = 3.14f;`       | Wrapper for `float`            |
| `Double`    | 64-bit | Immutable  | `Double d = 3.14;`       | Wrapper for `double`           |
| `String`    | N/A    | Immutable  | `String s = "hello";`    | Textual data                   |
| `Array`     | N/A    | Mutable    | `int[] arr = {1, 2, 3};` | Fixed-size, ordered collection |

ðŸ§  Mutability Notes:

* Wrapper classes (Integer -> int, Double -> double, etc.) is an object representation of a primitive data type. These classes as well as Strings are immutable, meaning their value cannot be changed after creation. Any operation creates a new object.

* Arrays are mutable, you can change their contents even though the reference points to the same memory.

**Immutable Example**
```java
String name = "Jordan";
String anotherName = name;

anotherName = "Alex";

// 'name' is still "Jordan" because 'String' is immutable
System.out.println(name);        // Jordan
System.out.println(anotherName); // Alex

```
![Reference Types Imutable](/img/reference-types-immutable.png)


**Mutable Example**
```java
int[] numbers = {1, 2, 3};
int[] moreNumbers = numbers;

moreNumbers[0] = 99;

// Both variables now point to the same array in memory
System.out.println(numbers[0]);     // 99
System.out.println(moreNumbers[0]); // 99
```

![Reference Types Mutable](/img/reference-types-mutable.png)


---

## ðŸ”„ Type Conversion

### Type Promotion (Widening)

Java automatically converts smaller types to larger types without losing data as the larger type can fully represent the smaller type's range.
#### Order of promotion
```
byte â†’ short â†’ int â†’ long â†’ float â†’ double
               â†‘
             char
```
#### Example of promoting int to float and long
```java
int i = 10;
long l= i;
float f = l;

System.out.println("int: " + i);
System.out.println("long: " + l);
System.out.println("float: " + f);
```
**Output:**
```
int: 10
long: 10
float: 10.0
```
#### Why is float considered larger than long in Java?
Even though long is a 64 bit integer, and float is a 32 bit floating point, Java treats float as "wider" as a float can represent a larger range of values
Analogy:
Imagine long is a list of whole numbers between 1 and 10:
```
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
```

Whereas a float (to 1 decimal place) could store:
```
1.0, 1.1, 1.2, ..., 9.8, 9.9, 10.0
```

This is already more distinct values than the integer-only long in this small range and in reality floats can store values in the millions, billions, and even tiny decimals like 0.000001.

#### Type Promotion Rules
* Only works from smaller to larger types in terms of range, not just byte size
* works between primitives of compatible types (char can be promoted to int and anything larger because it can be represented by a unicode number)

```java
char c = 'A'; // 'A' in Unicode is 65
int i = c;

System.out.println("int: " + c);
```
**Output:**
```
65
```
### Casting (Narrowing)

Type casting is when you convert a value from a larger type to a smaller type. This cannot be done automatically and needs to be explicitly cast to the smaller value as there is a risk of data loss.

#### When casting is necessary
Casting can be used when you want to perform operations between different data types or you need to store a value of one type in a variable of another type.

```java
double pi = 3.14;
int i = (int) pi;

System.out.println(i);

```
**Output:**
```
3
```
### Example of overflow when casting
```java
int big = 130;
byte small = (byte) big; // byte range: -128 to 127

System.out.println(small);
```
**Output:**

```
-126
```

The byte value wraps around to the lower end of the range because 130 is too large for a byte.

---

## ðŸ§  Final Keyword (Constants)

Use `final` to make a variable **constant**.

```java
final double PI = 3.14159;

```

Once assigned, it canâ€™t be changed.

---

## âœ… Summary

- Variables store data and must be typed.
- Java has **8 primitive types** and many reference types.
- Use `final` to declare constants.
- Be careful with **type conversions** to avoid data loss.

---
ðŸ“š Learn more:
- [Variable Scope](./variable-scope)
- [Modifiers: public, private, static, final](./modifiers)

[â¬… Back to Java Basics](notion://www.notion.so/roadmap/java/basics)