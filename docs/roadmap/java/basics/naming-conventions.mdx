---
id: java-naming-conventions
title: ✏️ Java Naming Conventions
sidebar_label: Naming Conventions
slug: /roadmap/java/basics/naming-conventions
---
import GlossaryTooltip from '@site/src/components/GlossaryTooltip';
import MarkRead from '@site/src/components/MarkRead';
import BackLink from '@site/src/components/BackLink';

<MarkRead url="/roadmap/java/basics/naming-conventions" />

# Java Naming Conventions

Naming things correctly is one of the most important parts of writing readable and maintainable code. Java has rules that are enforced by the compiler (for example, valid characters, no spaces, not starting with a digit), but it also has widely adopted naming conventions. These conventions aren’t enforced by the language, but they help developers keep code consistent, understandable, and easy to work with in teams.

---

## On this page you’ll learn:
- The standard Java naming conventions
- The difference between compiler-enforced rules and style conventions
- Naming conventions for **variables, methods, classes, constants, packages, and more**
- Examples of good vs bad names and why conventions matter

---

## General Identifier Rules (Compiler-Enforced)

These apply to *all* identifiers (variables, methods, classes, etc.):  

What names can be:
- Letters, digits, underscores (`_`), or dollar signs (`$`)
- Start with a **letter**, underscore, or dollar sign (not a digit)
- Case-sensitive (`age` ≠ `Age`)

What names cannot be:
- Start with a digit (`2count`)
- Contain spaces or special characters (`total-cost`, `user@name`)
- Be a reserved <GlossaryTooltip term="keyword" definition="Words reserved by the Java language with special meaning, like `class`, `if`, `static`." link="/glossary/keyword" bold="true" />

Valid Examples:
```java
int count;
double _value; 
float $price;
```
Invalid Examples:
```java
int 2count; 
double class; 
float total-cost;
```
---

## Case Styles
Before looking at Java specifically, here are the common case styles used in programming:

- **camelCase** → First word is lowercase and all subsequent words begin with a capital letter

    `camelCaseNamingConvention`
- **PascalCase (UpperCamelCase)** → All words begin with a capital letter

    `PascalCaseNamingConvention`
- **snake_case** → All words are lowercase and separated by an underscore (`_`) This is not used in Java, but common in Python  

    `snake_case_naming_convention` 

- **CONSTANT_CASE** or **SCREAMING_SNAKE_CASE** → Snake case but all letters are capitalised.

    `SCREAMING_SNAKE_CASE_NAMING_CONVENTION`
- **kebab-case** → All words separated by a dash (`-`) not used in Java, but common in CSS/URLs

    `kebab-case-naming-convention`

---

## Variables  

Variable names should be short, but descriptive. A good name makes the purpose 
of the variable clear to anyone reading the code, without needing extra explanation. 
While Java allows variable names to start with an underscore (`_`) or 
dollar sign (`$`), these should generally be avoided as they reduce readability.

Variable names should be **mnemonic**, meaning they should give a clear hint about their intended use. One-character variable names are discouraged except for **temporary variables**, where short names are common. By convention:  
- `i`, `j`, `k`, `m`, `n` are often used for integer counters  
- `c`, `d`, `e` may be used for characters  

**`camelCase`** is always used for variables.

#### Naming with Data Types  

Variable names should often reflect both the **type of data** and the **role** it plays in the program.  

Here are some examples of good naming practices across common Java types:  

**Booleans** should read like a question or states
```java
boolean hasPassed;
boolean isEmpty
```

**Strings** represent text data, more often Nouns
```java
String customerName;
String addressLine1;
```

**Collections** use plural names or should describe the relationship between their elements
```java
List<String> users;
Map<Integer, Order> ordersByUserId;
```

**Units of Measurement** should always include the unit in the name
```java
long timeoutMs;
double distanceKm;
float weightKg;
```
---

## 3. Methods

Method names should be **descriptive and action-oriented**. A good method name 
makes it clear what the method does, and what kind of result (if any) it produces.  
Unlike variables, methods almost always start with a **verb**, since they perform 
an action. Method names in Java always use **camelCase**.  

As with variable names, while Java allows identifiers to begin with an underscore (`_`) 
or dollar sign (`$`), this should be avoided in practice. Normal developer-written 
methods should always start with a letter for clarity and consistency. 

#### Naming with Return Types

**Boolean** returning methods should be phrased like questions or states
```java
boolean isEmpty();
boolean hasPermission(User user);
```

**Value** returning methods (e.g. Strings, numbers, computed results) should describe the value they are Returning
```java
int calculateSum(int a, int b);
String formatCurrency(double amount);
```

**Object** returning methods should use get for access to properties, and `find`/`load`/`fetch` for retrieving from somewhere (i.e. a datasource)
```java
String getName();
User findUserById(long id);
Order loadOrder(long id);
```

**Collection** returning methods should use plurals or describe the filter/group it returnsZ_whenConditionMet
```java
List<Order> listOrders();
List<User> findUsersByRole(String role);
Map<Long, Order> getOrdersById(Set<Long> ids);
```
**Side Effect (void)** returning methods should be named after the task they perform, using action verbs (avoid `get`)
```java
void printInvoice(Invoice invoice);
void updateStatus(Order order, Status status);
void sendEmail(Message message, User recipient);
```

**Creation/Conversion** methods should describe the construction or transformation of the data
```java
Invoice createInvoice(Order order);
static User fromDto(UserDto userDto);
String toJson();
```


## 4. Classes, Interfaces, Enums, Records

These identifiers usually represent **types** in Java, and so their names should be 
clear, descriptive, and consistent. All of them use **`PascalCase`**, where each word 
starts with a capital letter.  

### Classes
Classes usually represent **real-world concepts or entities** in your program, 
so their names should be **nouns**

```java
public class BankAccount { ... };
public class UserProfile { ... };
```

### Interfaces
Interfaces often describe **capabilities**, **contracts**, or **behaviour**, so adjectives are common,
though nouns are also possible when the interface defines a role.

```java
public interface Readable { ... }; 
publice interface Comparable { ... };
```

### Enums
Enums are classes that define a fixed set of constants.
- The name of the enum is written in **`PascalCase`**
- The members of the enum are written in **`SCREAMING_SNAKE_CASE`**
```java
public enim Status {
    PENDING,
    APPROVED,
    REJECTED,
    IN_PROGRESS,
    ON_HOLD,
    CANCELLED
}
```

### Records (Java 14+)
Records are special classes for **immutable data carriers**. They’re ideal when you just need 
to hold values and avoid boilerplate, since Java automatically generates `equals`, `hashCode`, 
`toString`, and getters. Use a regular class instead if the object needs **behavior, mutability, 
or inheritance**. They follow the same naming convention as classes, using **`PascalCase`**.

```java
public record Point(int x, int y) {}
public record PersonRecord(String name, int age) {}
```
---

## Constants  

Constants represent values that **never change** (declared with `static final`).  
They should be written in **`SCREAMING_SNAKE_CASE`**, where all letters are uppercase 
and words are separated by underscores. This convention makes constants stand out 
clearly from regular variables.  

```java
public static final int MAX_USERS = 100;
public static final String DEFAULT_REGION = "eu-west-1";
public static final double PI = 3.14159;
```
---

## Packages & Modules  

Packages and modules group related classes together. Their names are written in 
**all lowercase**, usually following a **reverse domain name style** (e.g. `com.example.myapp`).  
This avoids conflicts between organisations and keeps names consistent.  
Underscores (`_`) and dashes (`-`) should never be used.  

```java
package com.mycompany.myproject;

module com.mycompany.myproject {}
```

---

## Type Parameters (Generics)  

Generics let you write classes, interfaces, and methods that can work with 
**different data types** while still being **type-safe**. Instead of creating 
separate versions of a class for `String`, `Integer`, etc., you can use a 
**type parameter** as a placeholder. The compiler then enforces that only the 
correct type is used.  

By convention, type parameters are written as **single uppercase letters**:  
- `T` → Type (a generic placeholder)  
- `E` → Element (commonly used in collections)  
- `K`, `V` → Key and Value (for maps)  
- `R` → Return type (for methods that return generics)  

```java
public class Box<T> { ... }
public interface List<E> { ... }
public interface Map<K, V> { ... }
```


---

## Annotations

Annotations are a form of metadata in Java, used to provide information to the 
compiler, runtime, or frameworks. They are written with `@` before the name and 
are usually used to mark properties, constraints, or capabilities.  

Annotation names use **`PascalCase`**, just like classes and interfaces.  

### Examples  

```java
public @interface NotNull {}
public @interface Override {}
public @interface Deprecated {}
```
---

## Tests

Test names should clearly describe the **behavior being tested** and the **condition** under which it happens.  
This makes tests double as documentation, so failures are easy to understand.  

Common naming styles:  
- `shouldDoX_whenY` → describes expected behavior under a condition  
- `returnsZ_whenCondition` → shows the return value under a condition  
- `givenWhenThen` → expresses behavior in BDD style (`givenX_whenY_thenZ`)

Tests can use **`camelCase`** or **`snake_case`**, but consistency is more important than style.  

```java
@Test
public void shouldCalculateTotal_whenCartNotEmpty() { ... }

@Test
public void returnsZero_whenCartIsEmpty() { ... }

@Test
public void isEligible_returnsTrue_whenAgeIs18OrMore() { ... }
```
A nested test class (annotated with **`@Nested`**) is an inner class used to group related test cases together 
under a shared context, making test names shorter and easier to read.
```java
class CartTest {

    @Nested
    class WhenCartIsEmpty {
        @Test void returnsZero() { ... }
        @Test void hasNoItems() { ... }
    }

    @Nested
    class WhenCartHasItems {
        @Test void sumsItems() { ... }
        @Test void appliesDiscounts() { ... }
    }
}
```

---

## Acronyms & Edge Cases  

In Java, acronyms should be written using the **normal case rules** for identifiers:  

- **`PascalCase`** (classes, interfaces, records): `HttpClient`, `JsonParser`, `UrlEncoder`  
- **`camelCase`** (variables, methods): `httpClient`, `jsonData`, `urlString`  
- **`UPPER_SNAKE_CASE`** (constants): `MAX_HTTP_SIZE`, `SUPPORTED_JSON_TYPES`  

This keeps acronyms consistent with other words and avoids distracting all-caps inside names.  

#### Edge Cases  

Short acronyms like **ID, URL, DB, IP** are treated inconsistently across codebases.  

- **Modern style:** treat them as normal words. `userId`, `urlString`, `dbConnection`, `ipAddress`.  
- **Legacy/older style:** keep the acronym uppercase. `userID`, `URLParser`, `DBConnection`, `IPAddress`.  

Both are correct in practice — the key is to be **consistent** in your project.  

---

## Common Mistakes

Even when following conventions, it’s easy to slip into poor naming habits.  
Here are some common pitfalls to avoid:  

**Generic names** are too vague to be meaningful  
  ```java
  int tmp; 
  String data; 
  double value1;
  ```
**Misleading names** where the name doesnt match the type or usage
```java
Map<Integer, User> users;   // this is a Map, not a List
long timeout;   // no unit specified
```

**Negated Booleans** can be double negatives and be confusing
```java
boolean notVisible;   // forces the reader to think in negatives
boolean isHidden;     // clearly describes the state
```
**Shouting long acronyms** breaks consistency
```java
class HTMLParser {}
```
**Redundant names** mean we are unneccessarily repeating type information
```java
List<User> userList;   // type already tells us it's a List
List<User> users;      // clearer and more natural

Map<Integer, User> userMap;   // repeats type
Map<Integer, User> usersById; // describes intent
```
---

## Quick Reference Table

| Category       | Convention             | Examples                                        |
|----------------|------------------------|-------------------------------------------------|
| Variables      | camelCase              | `userName`, `accountBalance`                    |
| Booleans       | is/has/can/should      | `isEmpty`, `hasAccess`, `canRetry`, `shouldSave`|
| Methods        | camelCase, verbs       | `calculateTotal()`, `printReport()`, `sendEmail()` |
| Classes        | PascalCase, nouns      | `BankAccount`, `UserProfile`                    |
| Interfaces     | PascalCase, adjectives | `Readable`, `Comparable`, `Serializable`        |
| Enums          | PascalCase             | `DayOfWeek`, `Status`                           |
| Enum values    | UPPER_SNAKE_CASE       | `MONDAY`, `IN_PROGRESS`                         |
| Records        | PascalCase, nouns      | `Point`, `PersonRecord`                         |
| Constants      | UPPER_SNAKE_CASE       | `MAX_USERS`, `DEFAULT_TIMEOUT_MS`               |
| Packages       | lowercase              | `com.example.myapp`                             |
| Modules        | lowercase              | `com.example.myproject`                         |
| Generics       | Single uppercase letter| `T`, `E`, `K`, `V`, `R`                         |
| Annotations    | PascalCase             | `@NotNull`, `@Override`, `@Deprecated`          |
| Tests          | Behavior-based         | `shouldDoX_whenY`, `returnsZ_whenConditionMet`  |
| Acronyms       | Normal casing rules    | `HttpClient`, `urlString`, `MAX_HTTP_SIZE`      |

---

## Summary  

- **Compiler rules:** identifiers can’t start with digits, contain spaces, or use reserved keywords; Java is case-sensitive.  
- **Variables:** use camelCase, short but descriptive; avoid `_` or `$` prefixes.  
- **Booleans:** use positive, state-like names (`isEmpty`, `hasAccess`), avoid negations (`notVisible`).  
- **Methods:** camelCase, verbs describing action; `get` for properties, `find/load/fetch` for retrieval, action verbs for void methods.  
- **Classes/Interfaces/Records:** PascalCase; classes as nouns, interfaces as capabilities/roles, records as simple data carriers.  
- **Enums:** PascalCase type name; enum constants in UPPER_SNAKE_CASE.  
- **Constants:** always UPPER_SNAKE_CASE.  
- **Packages/Modules:** all lowercase, reverse domain style.  
- **Generics:** single uppercase letters (`T`, `E`, `K`, `V`, `R`).  
- **Annotations:** PascalCase, describe property or capability.  
- **Tests:** names describe expected behavior + condition (`shouldX_whenY`); use `@Nested` to group scenarios.  
- **Acronyms:** follow normal casing rules (`HttpClient`, `urlString`), constants remain uppercase (`MAX_HTTP_SIZE`). Edge cases like `ID`/`URL` vary, but consistency is key.  
---

Learn more:
- [Variables & Data Types](/roadmap/java/basics/variables-data-types)
- [Keyword Glossary Entry](/glossary/keyword)

<BackLink />